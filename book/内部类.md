## 1. 参数传递

### 1.1 类名作为形参和返回值（应用）

* 1、类名作为方法的形参

  方法的形参是类名，其实需要的是该类的对象

  实际传递的是该对象的【地址值】

* 2、类名作为方法的返回值

  方法的返回值是类名，其实返回的是该类的对象

  实际传递的，也是该对象的【地址值】

* 示例代码：

  ```java
  class Cat {
      public void eat() {
          System.out.println("猫吃鱼");
      }
  }
  class CatOperator {
      public void useCat(Cat c) { //Cat c = new Cat();
          c.eat();
      }
      public Cat getCat() {
          Cat c = new Cat();
          return c;
      }
  }
  public class CatDemo {
      public static void main(String[] args) {
          //创建操作类对象，并调用方法
          CatOperator co = new CatOperator();
          Cat c = new Cat();
          co.useCat(c);
  
          Cat c2 = co.getCat(); //new Cat()
          c2.eat();
      }
  }
  ```

### 1.2 抽象类作为形参和返回值（理解）

* 抽象类作为形参和返回值

  * 方法的形参是抽象类名，其实需要的是该抽象类的子类对象
  * 方法的返回值是抽象类名，其实返回的是该抽象类的子类对象

* 示例代码：

  ```java
  abstract class Animal {
      public abstract void eat();
  }
  class Cat extends Animal {
      @Override
      public void eat() {
          System.out.println("猫吃鱼");
      }
  }
  class AnimalOperator {
      public void useAnimal(Animal a) { //Animal a = new Cat();
          a.eat();
      }
      public Animal getAnimal() {
          Animal a = new Cat();
          return a;
      }
  }
  public class AnimalDemo {
      public static void main(String[] args) {
          //创建操作类对象，并调用方法
          AnimalOperator ao = new AnimalOperator();
          Animal a = new Cat();
          ao.useAnimal(a);
  
          Animal a2 = ao.getAnimal(); //new Cat()
          a2.eat();
      }
  }
  ```

### 1.3 接口名作为形参和返回值（理解）

* 接口作为形参和返回值

  * 方法的形参是接口名，其实需要的是该接口的实现类对象
  * 方法的返回值是接口名，其实返回的是该接口的实现类对象

* 示例代码：

  ```java
  interface Jumpping {
      void jump();
  }
  class JumppingOperator {
      public void useJumpping(Jumpping j) { //Jumpping j = new Cat();
          j.jump();
      }
      public Jumpping getJumpping() {
          Jumpping j = new Cat();
          return j;
      }
  }
  class Cat implements Jumpping {
      @Override
      public void jump() {
          System.out.println("猫可以跳高了");
      }
  }
  public class JumppingDemo {
      public static void main(String[] args) {
          //创建操作类对象，并调用方法
          JumppingOperator jo = new JumppingOperator();
          Jumpping j = new Cat();
          jo.useJumpping(j);
  
          Jumpping j2 = jo.getJumpping(); //new Cat()
          j2.jump();
      }
  }
  
  ```

## 2. 内部类

### 2.1 内部类的基本使用（理解）

* 内部类概念

  * 在一个类中定义一个类。举例：在一个类A的内部定义一个类B，类B就被称为内部类

* 内部类定义格式

  * 格式&举例：

    ```java
    /*
    	格式：
        class 外部类名{
        	修饰符 class 内部类名{
        	
        	}
        }
    */
    
    class Outer {
        public class Inner {
            
        }
    }
    ```

* 内部类的访问特点 

  * 内部类可以直接访问外部类的成员，包括私有
  * 外部类要访问内部类的成员，必须创建对象

* 示例代码：

  ```java
  /*
      内部类访问特点：
          内部类可以直接访问外部类的成员，包括私有
          外部类要访问内部类的成员，必须创建对象
   */
  public class Outer {
      private int num = 10;
      public class Inner {
          public void show() {
              System.out.println(num);
          }
      }
      public void method() {
          Inner i = new Inner();
          i.show();
      }
  }
  ```

### 2.2 成员内部类（理解）

* 成员内部类

  * 在类中方法，跟成员变量是一个位置
  * 成员内部类中不能存在任何静态变量和静态方法，但是可以存在静态常量

* 外界创建成员内部类格式

  * 格式：外部类名.内部类名 对象名 = 外部类对象.内部类对象;
  * 举例：Outer.Inner oi = new Outer().new Inner();

* 成员内部类的推荐使用方案

  * 将一个类，设计为内部类的目的，大多数都是不想让外界去访问，所以内部类的定义应该私有化，私有化之后，再提供一个可以让外界调用的方法，方法内部创建内部类对象并调用。

* 示例代码：

  ```java
  class Outer {
      private int num = 10;
      private class Inner {
          public void show() {
              System.out.println(num);
          }
      }
      public void method() {
          Inner i = new Inner();
          i.show();
      }
  }
  public class InnerDemo {
      public static void main(String[] args) {
  		//Outer.Inner oi = new Outer().new Inner();
  		//oi.show();
          Outer o = new Outer();
          o.method();
      }
  }
  ```

### 2.3 局部内部类（理解）

* 局部内部类定义位置

  * 局部内部类是在方法中定义的类

* 局部内部类方式

  * 局部内部类，外界是无法直接使用，需要在方法内部创建对象并使用
  * 该类可以直接访问外部类的成员，也可以访问方法内的局部变量

* 示例代码

  ```java
  class Outer {
      private int num = 10;
      public void method() {
          int num2 = 20;
          class Inner {
              public void show() {
                  System.out.println(num);
                  System.out.println(num2);
              }
          }
          Inner i = new Inner();
          i.show();
      }
  }
  public class OuterDemo {
      public static void main(String[] args) {
          Outer o = new Outer();
          o.method();
      }
  }
  
  ```

### 2.4 静态内部类

* 静态内部类的定义位置

  在类中方法，跟成员变量是一个位置

* 静态内部类使用：

  1、 静态内部类不能直接访问外部类的非静态成员，但可以通过 new 外部类().成员 的方式访问

  2、 如果外部类的静态成员与内部类的成员名称相同，可通过“类名.静态成员”访问外部类的静态成员；如果外部类的静态成员与内部类的成员名称不相同，则可通过“成员名”直接调用外部类的静态成员

  3、 创建静态内部类的对象时，不需要外部类的对象，可以直接创建 内部类 对象名= new 内部类();

  示例代码：

  ```java
  public class Outer{
  	private int a=99;
  	static int b=10;
  	
  	public static class Inner{
  		int b=2;
  		public  void test(){
  		System.out.println("访问外部类中的b:"+Outer.b);
  		System.out.println("访问的内部类的b:"+Outer.b);
  		}
  	}
  	public static void main(String [] args){
  		Inner in=new Inner();
  		in.test();
  	}
  }
  ```

  

  


### 2.5 匿名内部类（应用）

* 匿名内部类的前提

  * 存在一个类或者接口，这里的类可以是具体类也可以是抽象类

* 匿名内部类的格式

  * 格式：new 类名 ( ) {  重写方法 }    new  接口名 ( ) { 重写方法 }

  * 举例： 

    ```java
    new Inter(){
        @Override
        public void method(){}
    } 
    ```

* 匿名内部类的本质

  * 本质：是一个继承了该类或者实现了该接口的子类匿名对象

* 匿名内部类的细节

  * 匿名内部类可以通过多态的形式接受

    ```java
    Inter i = new Inter(){
      @Override
        public void method(){
            
        }
    }
    ```

* 匿名内部类直接调用方法

  ```java
  interface Inter{
      void method();
  }
  
  class Test{
      public static void main(String[] args){
          new Inter(){
              @Override
              public void method(){
                  System.out.println("我是匿名内部类");
              }
          }.method();	// 直接调用方法
      }
  }
  ```

### 2.6 匿名内部类在开发中的使用（应用）

* 匿名内部类在开发中的使用

  * 当发现某个方法需要，接口或抽象类的子类对象，我们就可以传递一个匿名内部类过去，来简化传统的代码

* 示例代码：

  ```java
  interface Jumpping {
      void jump();
  }
  class Cat implements Jumpping {
      @Override
      public void jump() {
          System.out.println("猫可以跳高了");
      }
  }
  class Dog implements Jumpping {
      @Override
      public void jump() {
          System.out.println("狗可以跳高了");
      }
  }
  class JumppingOperator {
      public void method(Jumpping j) { //new Cat();   new Dog();
          j.jump();
      }
  }
  class JumppingDemo {
      public static void main(String[] args) {
          //需求：创建接口操作类的对象，调用method方法
          JumppingOperator jo = new JumppingOperator();
          Jumpping j = new Cat();
          jo.method(j);
  
          Jumpping j2 = new Dog();
          jo.method(j2);
          System.out.println("--------");
  
          // 匿名内部类的简化
          jo.method(new Jumpping() {
              @Override
              public void jump() {
                  System.out.println("猫可以跳高了");
              }
          });
  		// 匿名内部类的简化
          jo.method(new Jumpping() {
              @Override
              public void jump() {
                  System.out.println("狗可以跳高了");
              }
          });
      }
  }
  ```

